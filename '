#include "paul.h"
#include <string.h>

double get_dA( double );
double get_dV( double , double );
double get_moment_arm( double , double );

double mindt( double * , double , double );

double getmindt( struct domain * theDomain ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;

   double dt = 1e100;
   int i;
   for( i=1 ; i<Nr-1 ; ++i ){
      int im = i-1;
      struct cell * c = theCells+i;
      double dr = c->dr;
      double wm = theCells[im].wiph;
      double wp = c->wiph;
      double w = .5*(wm+wp);
      double dt_temp = mindt( c->prim , w , dr );
      if( dt > dt_temp ) dt = dt_temp;
   }
   dt *= theDomain->theParList.CFL; 
   MPI_Allreduce( MPI_IN_PLACE , &dt , 1 , MPI_DOUBLE , MPI_MIN , MPI_COMM_WORLD );

   return( dt );
}

void initial( double * , double * );
void prim2cons( double * , double * , double , double );
void cons2prim( double * , double * , double , double );
double get_vr( double * );

void set_wcell( struct domain * theDomain ){

   struct cell * theCells = theDomain->theCells;
   int mesh_motion = theDomain->theParList.Mesh_Motion;
   int Nr = theDomain->Nr;


   int i;
   for( i=0 ; i<Nr-1 ; ++i ){
      struct cell * cL = theCells+i;  
      double w = 0.0;
      if( mesh_motion ){
         struct cell * cR = theCells+i+1;
         double wL = get_vr( cL->prim );
         double wR = get_vr( cR->prim );
         w = .5*(wL + wR); 
      }
      cL->wiph = w;
   }
}

void adjust_RK_cons( struct domain * theDomain , double RK ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;

   int i,q;
   for( i=0 ; i<Nr ; ++i ){
      struct cell * c = theCells+i;
      for( q=0 ; q<NUM_Q ; ++q ){
         c->cons[q] = (1.-RK)*c->cons[q] + RK*c->RKcons[q];
      }
   }
}

void move_cells( struct domain * theDomain , double RK , double dt){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;
   int i;
   for( i=0 ; i<Nr ; ++i ){
      struct cell * c = theCells+i;
      c->riph += c->wiph*dt;
   }

}

void calc_dr( struct domain * theDomain ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;

   int i;
   for( i=1 ; i<Nr ; ++i ){
      int im = i-1;
      double rm = theCells[im].riph;
      double rp = theCells[i ].riph;
      double dr = rp-rm;
      theCells[i].dr = dr;
   }
   if( theDomain->rank==0 ) theCells[0].dr = theCells[0].riph;

}


void calc_prim( struct domain * theDomain ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;

   int i;
   for( i=0 ; i<Nr ; ++i ){
      struct cell * c = theCells+i;
      double rp = c->riph;
      double rm = rp-c->dr;
      double r = get_moment_arm( rp , rm );
      double dV = get_dV( rp , rm );
      cons2prim( c->cons , c->prim , r , dV );
   }

}

void plm( struct domain *);
void riemann( struct cell * , struct cell * , double , double );

void radial_flux( struct domain * theDomain , double dt ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;
   int i;
   plm( theDomain );
   for( i=0 ; i<Nr-1 ; ++i ){
      struct cell * cL = theCells+i;
      struct cell * cR = theCells+i+1;
      double r = cL->riph;
      double dA = get_dA(r); 
      riemann( cL , cR , r , dA*dt );
   }

}

void source( double * , double * , double , double , double );
void source_alpha( double * , double * , double * , double , double );

void add_source( struct domain * theDomain , double dt ){

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;

   int i;
   for( i=0 ; i<Nr ; ++i ){
      struct cell * c = theCells+i;
      double rp = c->riph;
      double rm = rp-c->dr;
      double r = get_moment_arm(rp,rm);
      double dV = get_dV(rp,rm);
      source( c->prim , c->cons , rp , rm , dV*dt );
      source_alpha( c->prim , c->cons , c->grad , r , dV*dt );
   }   

}


void longandshort( struct domain * theDomain , double * L , double * S , int * iL , int * iS , int * rL , int * rS ){ 

   struct cell * theCells = theDomain->theCells;
   int Nr = theDomain->Nr;
   double rmax = theCells[Nr-1].riph;
   double rmin = theCells[0].riph;
   MPI_Allreduce( MPI_IN_PLACE , &rmax , 1 , MPI_DOUBLE , MPI_MAX , MPI_COMM_WORLD );
   MPI_Allreduce( MPI_IN_PLACE , &rmin , 1 , MPI_DOUBLE , MPI_MIN , MPI_COMM_WORLD );
   int Nr0 = theDomain->theParList.Num_R;
   double dr0 = rmax/(double)Nr0;
   double dx0 = log(rmax/rmin)/Nr0;
   int logscale = 0;

   double Long  = 0.0; 
   double Short = 0.0; 
   int iLong  = -1;
   int iShort = -1;
   int i;
   int imin = 1;
   int imax = Nr-1;
   if( rank!=0 )      imin = Ng;
   if( rank!=size-1 ) imax = Nr-Ng;
   for( i=1 ; i<Nr-1 ; ++i ){
      struct cell * c = theCells+i;
      double dy = c->dr;
      double dx = dr0;
      if( logscale ) dx = c->riph*dx0;
      double l = dy/dx;
      double s = dx/dy;
      if( Long  < l ){ Long  = l; iLong  = i; } 
      if( Short < s ){ Short = s; iShort = i; } 
   }

   int rank = theDomain->rank;
   struct { double value ; int index ; } maxminbuf;
   maxminbuf.value = Short;
   maxminbuf.index = rank;
   MPI_Allreduce( MPI_IN_PLACE , &maxminbuf , 1 , MPI_DOUBLE_INT , MPI_MINLOC , MPI_COMM_WORLD );
   *rS = maxminbuf.index;

   maxminbuf.value = Long;
   maxminbuf.index = rank;
   MPI_Allreduce( MPI_IN_PLACE , &maxminbuf , 1 , MPI_DOUBLE_INT , MPI_MAXLOC , MPI_COMM_WORLD );
   *rL = maxminbuf.index;

   *iS = iShort;
   *iL = iLong;
   *S = Short;
   *L = Long;

}


void AMR( struct domain * theDomain ){

   double L,S;
   int iL=0;
   int iS=0;
   int rL=0;
   int rS=0;
   longandshort( theDomain , &L , &S , &iL , &iS , &rL , &rS );
   int rank = theDomain->rank;

   if( rank == rL ) printf("Rank %d; Long  = %e #%d\n",rank,L,iL);
   if( rank == rS ) printf("Rank %d; Short = %e #%d\n",rank,S,iS);

   double MaxShort = theDomain->theParList.MaxShort;
   double MaxLong  = theDomain->theParList.MaxLong;
/*
   if( S>MaxShort ){
      int iSp = (iS+1)%Np[jk];

      //Possibly shift iS backwards by 1
      int iSm = iS-1;
      if( iSm == -1 ) iSm = Np[jk]-1;
      double dpL = sweep[iSm].dphi;
      double dpR = sweep[iSp].dphi;
      if( dpL < dpR ){
         --iS;
         --iSm;
         --iSp;
         if( iS  == -1 ) iS  = Np[jk]-1;
         if( iSm == -1 ) iSm = Np[jk]-1;
         if( iSp == -1 ) iSp = Np[jk]-1;
      }

      //Remove Zone at iS+1
      sweep[iS].dphi  += sweep[iSp].dphi;
      sweep[iS].piph   = sweep[iSp].piph;
      sweep[iS].RKpiph = sweep[iSp].RKpiph;
      int q;
      for( q=0 ; q<NUM_Q ; ++q ){
         sweep[iS].cons[q]   += sweep[iSp].cons[q];
         sweep[iS].RKcons[q] += sweep[iSp].RKcons[q];
      }
      double phip = sweep[iS].piph;
      double phim = phip - sweep[iS].dphi;
      double xp[3] = {r_jph[j]  ,phip,z_kph[k]  };
      double xm[3] = {r_jph[j-1],phim,z_kph[k-1]};
      double r  = get_moment_arm( xp , xm );
      double dV = get_dV( xp , xm );
      cons2prim( sweep[iS].cons , sweep[iS].prim , r , dV );
      //Shift Memory
      int blocksize = Np[jk]-iSp-1;
      if( iSp != Np[jk]-1 ) memmove( sweep+iSp , sweep+iSp+1 , blocksize*sizeof(struct cell) );
      Np[jk] -= 1;
      *swptr = (struct cell *) realloc( sweep , Np[jk]*sizeof(struct cell) );
      sweep = *swptr;
      if( iS < iL ) iL--;

   }
*/

   if( L>MaxLong ){
      if( rank == rL ){
         Nr += 1;
         theCells = (struct cell *) realloc( theCells , Nr*sizeof(struct cell) );
         sweep = *swptr;
         int blocksize = Np[jk]-iL-1;
         memmove( sweep+iL+1 , sweep+iL , blocksize*sizeof(struct cell) );

         double dphi = sweep[iL].dphi;
         double phip = sweep[iL].piph;
         double phim = phip - dphi;
         double phi0 = .5*(phip+phim);

         sweep[iL].piph   = phi0;
         sweep[iL].RKpiph = phi0;
         sweep[iL].dphi   = .5*dphi;
         sweep[iL+1].dphi = .5*dphi;

         int q;
         for( q=0 ; q<NUM_Q ; ++q ){
            sweep[iL].cons[q]     *= .5;
            sweep[iL].RKcons[q]   *= .5;
            sweep[iL+1].cons[q]   *= .5;
            sweep[iL+1].RKcons[q] *= .5;
         }

         double xp[3] = {r_jph[j]  ,phi0,z_kph[k]  };
         double xm[3] = {r_jph[j-1],phim,z_kph[k-1]};
         double dV = get_dV( xp , xm );
         double r  = get_moment_arm( xp , xm );
         cons2prim( sweep[iL].cons , sweep[iL].prim , r , dV );
 
         xp[1] = phip;
         xm[1] = phi0;
         dV = get_dV( xp , xm );
         r  = get_moment_arm( xp , xm );
         cons2prim( sweep[iL+1].cons , sweep[iL+1].prim , r , dV );
      }
   }

}


